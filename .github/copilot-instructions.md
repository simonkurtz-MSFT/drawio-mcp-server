---
applyTo: "**"
---

# GitHub Copilot Instructions for this Repository

## Project Overview

This is a **TypeScript MCP (Model Context Protocol) server** for programmatic Draw.io diagram generation. It produces standard Draw.io XML directly — no browser extension or Draw.io instance required.

- **Runtime**: Node.js ≥ 24, pnpm
- **Language**: TypeScript (strict mode)
- **Key dependencies**: `@modelcontextprotocol/sdk`, `hono` (HTTP transport), `zod` (input validation), `fuzzy-search`
- **Test framework**: Vitest with V8 coverage

### Repository Structure

- `src/` — Source code
  - `src/index.ts` — Entry point, server lifecycle (startup, shutdown, transport)
  - `src/tool_definitions.ts` — Centralized tool metadata (names, descriptions, Zod input schemas, `TOOL_NAMES` constant)
  - `src/tool_registrations.ts` — Loops over `TOOL_DEFINITIONS` to register all tools on the MCP server
  - `src/tools.ts` — Tool handler implementations (the `handlers` object)
  - `src/tool_handler.ts` — Factory that wires handlers to the MCP server
  - `src/diagram_model.ts` — Core diagram model (cells, layers, pages, XML generation)
  - `src/config.ts` — CLI/env configuration parsing (pure functions)
  - `src/utils.ts` — Shared utilities (`esmDirname`, `readRelativeFile` — ESM path helpers)
  - `src/instructions.md` — Server instructions sent to MCP clients during initialization
  - `src/shapes/` — Shape libraries (Azure icons, basic shapes)
  - `src/loggers/` — Logger implementations (console, MCP server)
- `tests/` — Test files (`*.test.ts`)
- `build/` — Compiled output (git-ignored, generated by `pnpm build`)
- `assets/azure-public-service-icons/` — Azure icon library XML

## Coding Conventions

- **Error handling**: Return `Error | T` union types instead of throwing exceptions. See `parseConfig()`, `parseHttpPortValue()`, and `parseLoggerType()` in `config.ts` for examples. In tool handlers, return `errorResult()` with a `StructuredError` containing `code`, `message`, and `suggestion` fields.
- **Pure functions**: Prefer pure functions with no side effects for logic (config parsing, validation). Side effects are isolated to `index.ts`.
- **Tool naming**: Tool name constants are centralized in the `TOOL_NAMES` object in `tool_definitions.ts` using `UPPER_SNAKE_CASE` keys (e.g., `TOOL_NAMES.ADD_CELLS`). Tool names exposed to MCP clients use `kebab-case` (e.g., `add-cells`).
- **Input validation**: All tool inputs are validated with Zod schemas defined in `tool_definitions.ts` and applied at registration time in `tool_registrations.ts`.
- **Shape resolution order**: When resolving shape names, the code checks in order: basic shapes (exact, case-insensitive) → Azure exact match (by title/ID) → Azure fuzzy search (top result). This priority prevents fuzzy search from hijacking basic shape names like "start" or "end".
- **ESM path helpers**: Use `esmDirname(import.meta.url)` (from `src/utils.ts`) instead of the raw `dirname(fileURLToPath(import.meta.url))` boilerplate for `__dirname`. Use `readRelativeFile(import.meta.url, ...segments)` to read a text file relative to the calling module.

## Adding New Tools

Follow this 3-step pattern:

1. **Define the tool** in `src/tool_definitions.ts` — add a `TOOL_DEFINITIONS` entry with key, name, description, `hasArgs`, and (if applicable) `inputSchema`.
2. **Add the handler** in `src/tools.ts` — add a new entry to the `handlers` object with the tool's `kebab-case` name as the key.
3. **Add tests** in `tests/` — create or extend a `*.test.ts` file covering the new handler logic.

`tool_registrations.ts` loops over `TOOL_DEFINITIONS` automatically — no manual registration step needed.

## Testing

- Tests live in `tests/*.test.ts` and use Vitest with Node environment.
- **Coverage thresholds** are enforced at **100%** for branches, functions, lines, and statements.
- `src/index.ts` is excluded from coverage (entry point with side effects).
- Run tests: `pnpm test` | Watch mode: `pnpm test:watch` | With coverage: `pnpm test:coverage`
- Always add or update tests when modifying tool handlers or core model logic.

## Build and CI

| Command | Description |
|---|---|
| `pnpm build` | Clean build (removes `build/`, then compiles via `tsconfig.build.json`) |
| `pnpm dev` | Watch mode — auto-rebuild on changes |
| `pnpm lint` | Type-check without emitting (uses `tsconfig.json`, which includes tests) |
| `pnpm test` | Run all tests |
| `pnpm test:coverage` | Run tests with V8 coverage |
| `pnpm inspect` | Launch MCP Inspector for interactive debugging |

- `tsconfig.build.json` is used for production builds (excludes tests).
- `tsconfig.json` includes everything (source + tests) and is used for linting and IDE support.

## Environment Variables

| Variable | Description |
|---|---|
| `AZURE_ICON_LIBRARY_PATH` | Path to Azure icon library XML file (auto-detected from `assets/` if unset) |
| `LOGGER_TYPE` | `console` (default) or `mcp_server` |
| `HTTP_PORT` | HTTP server port (default: `8080`, CLI `--http-port` takes precedence) |
| `TRANSPORT` | Transport type: `stdio`, `http`, or `stdio,http` (CLI `--transport` takes precedence) |

## Diagrams

> **Runtime conventions**: The diagram generation conventions below are also embedded in the MCP server's `instructions` field, loaded from `src/instructions.md` at startup. Any MCP client automatically receives these guidelines during initialization — no extra round trips. When updating conventions here, keep `src/instructions.md` in sync.

### General
- Use the Draw.io MCP server for all diagram generation tasks.
- When asked to create diagrams such as flowcharts, decision trees, technical architecture diagrams, etc., always use the Draw.io MCP server and XML format.
- Content returned from the Draw.io MCP server will be in XML format. Take this content and create or update a `.drawio` file in the repository with that content.

### Layout
- **Primary flow direction**: left-to-right unless otherwise specified. Each stage of the architecture occupies a vertical column.
- **Parallel/sibling services**: Services at the same stage in the flow (e.g., multiple compute options, multiple databases) must be stacked **vertically** within their column — never placed side by side horizontally. Horizontal position indicates sequence in the flow; vertical position indicates parallelism.
- **Orthogonal edges only**: All edges must use horizontal and vertical segments only — never diagonal. Edges may change direction multiple times with right-angle bends. Use `edgeStyle=orthogonalEdgeStyle` (the default).
- **Edge connection points — prefer sides**: Edges should exit and enter components through their **left or right sides**, not through the top or bottom. This aligns with the left-to-right flow direction and keeps the diagram clean. Use top/bottom connections only when edges connect vertically stacked sibling services within the same column or when side connections would cause unavoidable overlaps.
- **Edge symmetry**: Connecting lines should exhibit visual symmetry. When multiple edges fan out from a single source or converge into a single target, space them evenly and use consistent routing patterns (e.g., all edges leave from the same side of the source and enter the same side of their targets). Avoid mixing exit/entry sides arbitrarily — if one edge leaves a component from the right, sibling edges in the same flow should also leave from the right.
- **Edges entering groups — symmetric fan-out or group-level connection**: When an edge from an external source targets components inside a group/container, choose the approach based on the number of children:
  - **1–2 children**: Draw separate edges from the source to each child. The edges should enter the group and then split symmetrically — one angling up and one angling down — to connect to the vertically stacked children. This creates a clean, balanced fan-out inside the container.
  - **3+ children**: Connect a single edge from the source to the **group cell itself** rather than to individual children. This avoids visual clutter from many converging lines and keeps the diagram readable. The group-level connection implies the source feeds all children within it.
- **No overlapping**: Components must not overlap each other. The only exception is cells that are children of a group/container (e.g., resources inside a VNet, apps inside a Container Apps Environment). Within a group, children are positioned relative to the group but must still not overlap one another.
- **Group children must be visually inside their container**: When components belong to a group (e.g., three Container Apps inside a Container Apps Environment), ALL children must be positioned at coordinates that place them **within the group's visible boundary**. Size the group large enough to visually contain every child with padding. Stack sibling children vertically inside the group so they read as a cohesive unit. Never leave a child floating outside or on the edge of its parent group — the visual containment IS the meaning.
- **Cross-cutting and supporting services** (e.g., Azure Monitor, Microsoft Entra ID, Azure Key Vault, Azure Policy, Microsoft Defender for Cloud, Azure Container Registry) should be placed to the side of the main diagram flow — either in a row along the bottom or in a column along the right edge. Do **not** draw edges/lines from components to these services. Show them as standalone shapes with their label only — no edges, no annotations like "DNS Resolution" or "Image Pull", and no lines connecting them to consuming services. Their role is implied by their presence in the diagram.
- **Edges represent data/request flow only**: Only draw edges between services that are directly connected in the request or data path. Do not draw edges to indicate indirect relationships like DNS resolution, image pulls, secret retrieval, or monitoring.
- **Branch before entering containers — CRITICAL**: When a source connects to multiple targets and some targets are inside a group/container while others are outside it, the edges **MUST split BEFORE any edge reaches the container boundary**. Draw **separate, independent edges** from the source — one per target. The edge to the target **outside** the container must never visually enter, cross, or overlap the container's area. Route it **spatially around** the container — above it, below it, or behind it — using as many horizontal and vertical segments (zig-zags) as needed. Zig-zagging is always acceptable; crossing a container boundary is never acceptable. Place the source far enough from the container that all edges clearly diverge outside it. Example: Front Door connects to Container App 1 (inside a Container Apps Environment group) and API 2 (an App Service, outside the group). Draw edge 1 from Front Door rightward into the group to Container App 1. Draw edge 2 from Front Door downward (or upward), then rightward **around** the group boundary, then to API 2 which is positioned below (or above) the group. Edge 2 must travel entirely outside the group's visual rectangle.
- **Edges must not cross group boundaries they don't belong to**: An edge may only enter or exit a group/container if its source or target is a child of that group. If neither endpoint belongs to a group, the edge must be routed entirely outside that group's visual area — no crossing, touching, or overlapping the group border. When positioning components and routing edges, leave enough clearance (at least 60px) around groups so that passing edges can route around them without ambiguity. This rule applies even when the edge's path would be shorter through the group — visual clarity and correct containment semantics take priority over compactness.
- **Position outside-group targets to enable clean routing**: Components that are NOT children of a group but receive edges from the same source as group children should be placed **above or below** the group — not at the same vertical position behind it. This ensures edges to those components can route around the group with simple orthogonal segments rather than overlapping the group's area.

### Shape Selection
- Use stencils for all architecture components. Do not use basic shapes (rectangles, circles, etc.) to represent Azure or cloud services. Basic shapes are fine for flowcharts and general diagrams.
- Default to Azure icons and context for architecture diagrams unless otherwise specified. Use official Azure icons and colors for all components.
- **Azure icon naming**: Azure icons use their official Azure service names, often in plural form (e.g., "Front Doors", "Container Apps", "App Services", "Key Vaults", "Virtual Networks", "DNS Zones", "Log Analytics Workspaces"). When searching, use the full Azure service name — not abbreviations, generic terms, or single words like "azure". The fuzzy search is tolerant of singular/plural and minor variations, but more specific queries yield better results.
- **Search, don't guess**: Always call `search-shapes` before adding shapes. Review the results to confirm the matched shape name and use that exact name with `add-cells-of-shape`.

### Styling
- Use `get-style-presets` to apply consistent Azure, flowchart, or general color presets.

### Labels & Annotations
- Add labels for traffic paths (e.g., "HTTPS", "gRPC") or security boundaries (VNet/private endpoints) where they clarify the flow. Labels should not overlay stencils. Use whitespace for clarity.
- **Edge label placement**: Place edge labels consistently **above** the edge for horizontal segments and **to the left** of the edge for vertical segments, provided space permits. Labels must never overlap shapes or other labels. Use the edge style properties `verticalAlign=bottom` (which places the label above a horizontal edge) to achieve this positioning.
- Do **not** add labels for implied relationships like "DNS Resolution", "Image Pull", or "Secret Access" — these are covered by the presence of cross-cutting services.

### Batch-Only Workflow
- **Every array-based tool MUST be called exactly ONCE with ALL items. NEVER call a tool repeatedly for individual items:**
  - `search-shapes` — gather ALL queries, submit ONE call
  - `add-cells-of-shape` — gather ALL shapes, submit ONE call
  - `add-cells` — gather ALL raw cells/edges, submit ONE call
  - `edit-cells` — gather ALL updates, submit ONE call
  - `create-groups` — gather ALL groups, submit ONE call
  - `add-cells-to-group` — gather ALL assignments, submit ONE call
  - `set-cell-shape` — gather ALL shape updates, submit ONE call

### Containment & Layers
- Use `create-groups` and `add-cells-to-group` to represent containment (e.g., VNets containing subnets, resource groups holding resources). Size each group large enough to contain all its children with at least 20px padding on each side.
- Position children **relative to the group** using coordinates that fall within the group's bounds. Stack multiple children vertically inside the group. Verify that every child's position + size fits within the parent group's dimensions.
- For multi-page diagrams, use `create-page` and `set-active-page` to organize content across tabs (e.g., separate pages for networking, compute, and data layers).

### Import / Export
- To modify an existing `.drawio` file, read its XML content and pass it to `import-diagram`, make changes, then `export-diagram` to get the updated XML.
- Always save exported XML to a `.drawio` file.
- **Prefer compressed export**: When calling `export-diagram`, pass `compress: true` to reduce payload size by 60-80%. The server uses **deflate-raw** compression with **base64** encoding — the same format used by the Draw.io desktop app. The response includes a `compression` object indicating whether compression is enabled and, when enabled, the `algorithm` (`deflate-raw`) and `encoding` (`base64`) used. `import-diagram` automatically detects and decompresses compressed content.

### Saving .drawio Files Efficiently

When `export-diagram` returns a large result that gets written to a temporary `content.json` file, do NOT call `read_file` to read it back through the LLM. The exported XML does not need LLM comprehension — reading it back creates an expensive and slow cloud round-trip where the full payload is uploaded to the model and then written back down via `create_file`.

Instead, use a **local terminal command** to extract the `xml` property from the JSON and write the `.drawio` file directly on the user's machine:

**PowerShell (Windows):**
```powershell
$json = Get-Content '<temp-content-json-path>' -Raw | ConvertFrom-Json; $json.data.xml | Set-Content '<output-path>.drawio' -Encoding UTF8 -NoNewline
```

**Bash (macOS/Linux):**
```bash
cat '<temp-content-json-path>' | python3 -c "import sys,json; print(json.load(sys.stdin)['data']['xml'], end='')" > '<output-path>.drawio'
```

This approach:
- Keeps the exported diagram data entirely local — no upload to the LLM
- Eliminates the slowest step in the diagram generation workflow
- Produces identical output to the read-and-create approach

Always prefer this local extraction pattern when saving exported diagrams to `.drawio` files.
